<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CaÃ§ador de Memecoins ðŸ’Ž</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .animate-pulse-fast {
            animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            50% {
                opacity: .5;
            }
        }
        .glassmorphism {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .highlight-new-buy {
             background-color: rgba(234, 179, 8, 0.15) !important;
        }
        .highlight-new-buy:hover {
             background-color: rgba(234, 179, 8, 0.25) !important;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div id="alert-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div id="alert-box" class="border-4 rounded-2xl shadow-2xl p-8 max-w-lg w-full transform transition-all duration-300 scale-95">
            <div class="text-center">
                <svg id="alert-icon" xmlns="http://www.w3.org/2000/svg" class="h-20 w-20 mx-auto animate-ping" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <!-- Icon path will be set by JS -->
                </svg>
                <h2 id="alert-title" class="text-4xl font-bold text-white mt-4"></h2>
                <p id="alert-subtitle" class="text-xl mt-2"></p>
            </div>
            <div id="alert-content" class="mt-6 text-center bg-gray-800 bg-opacity-50 rounded-lg p-4">
                <!-- ConteÃºdo do alerta serÃ¡ inserido aqui -->
            </div>
            <button id="alert-close-btn" onclick="closeAlertModal()" class="mt-8 w-full text-white font-bold py-3 px-4 rounded-lg transition duration-300">
                Fechar
            </button>
        </div>
    </div>

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-white">ðŸ’Ž CaÃ§ador de Memecoins</h1>
            <p class="text-gray-400 mt-2">Monitore compras de tokens novos/desconhecidos por carteiras de baleias.</p>
             <p class="text-sm text-amber-400 mt-2">TransaÃ§Ãµes marcadas com ðŸ”¥ sÃ£o de tokens ainda nÃ£o listados no CoinGecko, um forte indicativo de memecoins ou novos projetos.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <!-- Configuration -->
            <div class="lg:col-span-1 glassmorphism rounded-2xl p-6">
                <h2 class="text-2xl font-bold mb-4 text-white">ConfiguraÃ§Ã£o</h2>
                <div class="mb-4">
                    <label for="wallets" class="block text-sm font-medium text-gray-300 mb-2">Carteiras para Monitorar (JSON)</label>
                    <textarea id="wallets" rows="12" class="w-full bg-gray-800 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-amber-500 focus:outline-none no-scrollbar"></textarea>
                </div>
                 <div class="mb-4">
                    <label for="alert-value" class="block text-sm font-medium text-gray-300 mb-2">Valor do Alerta (USD) para Tokens Conhecidos</label>
                    <input type="number" id="alert-value" class="w-full bg-gray-800 border border-gray-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-amber-500 focus:outline-none" value="100000">
                </div>
                <button id="start-btn" class="w-full bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300">
                    Iniciar Monitoramento
                </button>
                 <button id="stop-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 mt-4 hidden">
                    Parar Monitoramento
                </button>
            </div>

            <!-- Status -->
            <div class="lg:col-span-2 glassmorphism rounded-2xl p-6">
                <h2 class="text-2xl font-bold mb-4 text-white">Status da ConexÃ£o</h2>
                <div id="status-container" class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                    <!-- Status indicators will be injected here -->
                </div>
            </div>
        </div>
        
        <!-- Transaction Feed -->
        <div class="glassmorphism rounded-2xl p-6">
             <h2 class="text-2xl font-bold mb-4 text-white">Feed de TransaÃ§Ãµes</h2>
             <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-700">
                    <thead class="bg-gray-800 bg-opacity-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Status</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Rede</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Data/Hora</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Tipo</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Valor (Token)</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Valor (USD)</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Carteira</th>
                             <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">Link</th>
                        </tr>
                    </thead>
                    <tbody id="transaction-feed" class="bg-gray-900 bg-opacity-50 divide-y divide-gray-800">
                        <tr id="placeholder-row">
                            <td colspan="8" class="px-6 py-12 text-center text-gray-500">Aguardando inÃ­cio do monitoramento...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURAÃ‡ÃƒO INICIAL ---
        const walletTextarea = document.getElementById('wallets');
        const alertValueInput = document.getElementById('alert-value');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const transactionFeed = document.getElementById('transaction-feed');
        const placeholderRow = document.getElementById('placeholder-row');
        const statusContainer = document.getElementById('status-container');
        // Alert Modal Elements
        const alertModal = document.getElementById('alert-modal');
        const alertBox = document.getElementById('alert-box');
        const alertIcon = document.getElementById('alert-icon');
        const alertTitle = document.getElementById('alert-title');
        const alertSubtitle = document.getElementById('alert-subtitle');
        const alertContent = document.getElementById('alert-content');
        const alertCloseBtn = document.getElementById('alert-close-btn');


        const initialWallets = {
          "eth": [
            "0xF977814e90dA44b7ABCAbe529a459703075212d3", // Binance 8
            "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // Wrapped Ether (WETH)
            "0x267612d9a1e0595e011a3645b25a331165a60368"  // Kraken 13
          ],
          "bsc": [
            "0xF8B089224424A9560B54333621024044952404Fe", // Binance Wallet
            "0x1b81D678ffb9C0263b24A97847620C99d213eB14", // PancakeSwap V3: Router
            "0x55d398326f99059fF775485246999027B3197955"  // BUSD-T Stablecoin
          ],
          "arbitrum": [
            "0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a", // Arbitrum One: Bridge
            "0x321F653eED006AD1C29D174e17d96351BDe22649", // GMX: GLP Manager
            "0x617b3a3528f9e957455c1e87a89e4c1a8b1b42d2"  // Multichain: Router
          ]
        };

        walletTextarea.value = JSON.stringify(initialWallets, null, 2);

        const networkConfig = {
            eth: { name: 'Ethereum', symbol: 'ETH', coingeckoId: 'ethereum', explorer: 'https://etherscan.io/tx/', rpc: 'https://eth.llamarpc.com' },
            bsc: { name: 'BSC', symbol: 'BNB', coingeckoId: 'binancecoin', explorer: 'https://bscscan.com/tx/', rpc: 'https://bsc-dataseed.binance.org/' },
            arbitrum: { name: 'Arbitrum', symbol: 'ETH', coingeckoId: 'ethereum', explorer: 'https://arbiscan.io/tx/', rpc: 'https://arb1.arbitrum.io/rpc' }
        };

        let pollingIntervals = {};
        let lastProcessedBlock = {};
        let monitoredWallets = new Set();
        const MAX_FEED_ITEMS = 50;
        const priceCache = new Map();
        const CACHE_TTL = 5 * 60 * 1000; // 5 minutos

        // --- LÃ“GICA PRINCIPAL ---

        startBtn.addEventListener('click', () => {
            placeholderRow.classList.add('hidden');
            transactionFeed.innerHTML = '';
            statusContainer.innerHTML = '';
            startBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
            
            let walletsToMonitor;
            try {
                walletsToMonitor = JSON.parse(walletTextarea.value);
            } catch (error) {
                alert('O JSON das carteiras Ã© invÃ¡lido.');
                startBtn.classList.remove('hidden');
                stopBtn.classList.add('hidden');
                return;
            }
            
            stopMonitoring(); 

            monitoredWallets.clear();
            Object.values(walletsToMonitor).flat().forEach(addr => monitoredWallets.add(addr.toLowerCase()));
            
            for (const network in walletsToMonitor) {
                if (networkConfig[network] && walletsToMonitor[network].length > 0) {
                    createStatusIndicator(network, 'idle', 'Iniciando...');
                    lastProcessedBlock[network] = null;
                    pollNetwork(network); 
                    pollingIntervals[network] = setInterval(() => pollNetwork(network), 15000);
                }
            }
        });

        stopBtn.addEventListener('click', stopMonitoring);

        function stopMonitoring() {
            Object.keys(pollingIntervals).forEach(network => {
                clearInterval(pollingIntervals[network]);
                updateStatusIndicator(network, 'disconnected', 'Parado');
            });
            pollingIntervals = {};
            startBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
        }

        async function pollNetwork(network) {
            updateStatusIndicator(network, 'connecting', 'Buscando blocos...');
            try {
                const latestBlockNum = parseInt(await rpcRequest(network, 'eth_blockNumber', []), 16);

                if (lastProcessedBlock[network] === null) {
                    lastProcessedBlock[network] = latestBlockNum - 1;
                }
                
                if (latestBlockNum > lastProcessedBlock[network]) {
                    updateStatusIndicator(network, 'connected', `Analisando blocos ${lastProcessedBlock[network] + 1} a ${latestBlockNum}`);
                    for (let i = lastProcessedBlock[network] + 1; i <= latestBlockNum; i++) {
                        const block = await rpcRequest(network, 'eth_getBlockByNumber', ['0x' + i.toString(16), true]);
                        if (block && block.transactions) {
                            for (const tx of block.transactions) {
                                await processTransaction(tx, network);
                            }
                        }
                    }
                    lastProcessedBlock[network] = latestBlockNum;
                }
                 setTimeout(() => updateStatusIndicator(network, 'connected', 'Aguardando novos blocos...'), 2000);
            } catch (error) {
                console.error(`[${network.toUpperCase()}] Erro durante o polling:`, error);
                updateStatusIndicator(network, 'error', 'Erro na conexÃ£o RPC');
            }
        }
        
        async function rpcRequest(network, method, params) {
            const url = networkConfig[network].rpc;
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params })
            });
            const data = await response.json();
            if (data.error) throw new Error(`RPC Error: ${data.error.message}`);
            return data.result;
        }

        async function processTransaction(tx, network) {
            try {
                if (!tx || !tx.from) return;
                
                const fromAddr = tx.from.toLowerCase();
                const toAddr = tx.to ? tx.to.toLowerCase() : null;

                let relevantWallet = null;
                let type = null;

                if (monitoredWallets.has(fromAddr)) {
                    relevantWallet = fromAddr;
                    type = 'SAÃDA';
                } else if (toAddr && monitoredWallets.has(toAddr)) {
                    relevantWallet = toAddr;
                    type = 'ENTRADA';
                }

                if (!relevantWallet) return;
                
                let isUnknownToken = false;

                if (tx.input && tx.input.startsWith('0xa9059cbb') && toAddr) { // ERC20 transfer
                    const tokenContract = toAddr;
                    const amountHex = '0x' + tx.input.substring(74);
                    
                    const [symbol, decimals] = await getTokenInfo(tokenContract, network);
                    if (decimals === 0 && symbol === '???') return;
                    
                    const amount = parseFloat(BigInt(amountHex)) / (10 ** decimals);
                    const priceResult = await getPrice(network, tokenContract, symbol);
                    isUnknownToken = priceResult.isUnknown;
                    const usdValue = amount * priceResult.price;
                    
                    const txData = { network, txHash: tx.hash, type, wallet: relevantWallet, tokenSymbol: symbol, tokenValue: amount, usdValue, isUnknown: isUnknownToken };
                    displayTransaction(txData);
                    checkAlerts(txData);

                } else if (tx.value && BigInt(tx.value) > 0) { // Native transfer
                    const decimals = 18;
                    const amount = parseFloat(BigInt(tx.value)) / (10 ** decimals);
                    const { symbol, coingeckoId } = networkConfig[network];
                    const priceResult = await getPrice(coingeckoId);
                    const usdValue = amount * priceResult.price;
                    
                    const txData = { network, txHash: tx.hash, type, wallet: relevantWallet, tokenSymbol: symbol, tokenValue: amount, usdValue, isUnknown: false };
                    displayTransaction(txData);
                    checkAlerts(txData);
                }
            } catch (error) {
                console.error(`Falha ao processar a transaÃ§Ã£o ${tx.hash} na rede ${network}:`, error);
            }
        }
        
        const tokenInfoCache = new Map();
        async function getTokenInfo(contractAddress, network) {
            if (tokenInfoCache.has(contractAddress)) return tokenInfoCache.get(contractAddress);
             try {
                const symbolData = '0x95d89b41';
                const decimalsData = '0x313ce567';

                const symbolHex = await rpcRequest(network, 'eth_call', [{ to: contractAddress, data: symbolData }, 'latest']);
                const decimalsHex = await rpcRequest(network, 'eth_call', [{ to: contractAddress, data: decimalsData }, 'latest']);

                const symbol = hexToString(symbolHex);
                const decimals = (decimalsHex && decimalsHex !== '0x') ? parseInt(decimalsHex, 16) : 0;
                
                if (symbol && !isNaN(decimals)) {
                    const result = [symbol, decimals];
                    tokenInfoCache.set(contractAddress, result);
                    return result;
                }
             } catch (e) {
                 console.warn(`NÃ£o foi possÃ­vel buscar informaÃ§Ãµes do token ${contractAddress}.`, e);
             }
             return ['???', 0];
        }

        function hexToString(hex) {
            if (!hex || hex === '0x') return '???';
            let str = '';
            const cleanHex = hex.startsWith('0x') ? hex.substring(2) : hex;
            for (let i = 0; i < cleanHex.length; i += 2) {
                const charCode = parseInt(cleanHex.substr(i, 2), 16);
                if (charCode > 31 && charCode < 127) {
                    str += String.fromCharCode(charCode);
                }
            }
            return str.replace(/\u0000/g, '').trim();
        }

        async function getPrice(assetId, contractAddress = null, symbol = null) {
            const cacheKey = contractAddress || assetId;
            const cached = priceCache.get(cacheKey);
            if (cached && (Date.now() - cached.timestamp < CACHE_TTL)) {
                return cached.data;
            }

            try {
                let url;
                if (contractAddress && (assetId === 'bsc' || assetId === 'arbitrum' || assetId === 'eth')) {
                     const platformId = assetId === 'eth' ? 'ethereum' : assetId === 'bsc' ? 'binance-smart-chain' : 'arbitrum-one';
                     url = `https://api.coingecko.com/api/v3/simple/token_price/${platformId}?contract_addresses=${contractAddress}&vs_currencies=usd`;
                } else {
                     url = `https://api.coingecko.com/api/v3/simple/price?ids=${assetId}&vs_currencies=usd`;
                }
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`CoinGecko API request failed: ${response.statusText}`);
                const data = await response.json();
                
                let price = 0;
                let isUnknown = true;

                if (contractAddress && data[contractAddress.toLowerCase()] && data[contractAddress.toLowerCase()].usd) {
                    price = data[contractAddress.toLowerCase()].usd;
                    isUnknown = false;
                } else if (!contractAddress && data[assetId] && data[assetId].usd) {
                    price = data[assetId].usd;
                    isUnknown = false;
                }
                
                const result = { price, isUnknown };
                priceCache.set(cacheKey, { data: result, timestamp: Date.now() });
                return result;
            } catch (error) {
                console.error(`Erro ao buscar preÃ§o para ${assetId}/${symbol}:`, error);
                return { price: 0, isUnknown: true };
            }
        }

        function displayTransaction(txData) {
            const { network, txHash, type, wallet, tokenSymbol, tokenValue, usdValue, isUnknown } = txData;
            
            const row = document.createElement('tr');
            const isNewBuy = isUnknown && type === 'ENTRADA';
            row.className = `transition duration-150 ${isNewBuy ? 'highlight-new-buy' : 'hover:bg-gray-700'}`;
            
            const typeClass = type === 'ENTRADA' ? 'text-green-400' : 'text-red-400';
            const typeIcon = type === 'ENTRADA' ? 'â†“' : 'â†‘';

            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-center">${isUnknown ? '<span class="text-lg" title="Token Novo / Desconhecido">ðŸ”¥</span>' : ''}</td>
                <td class="px-6 py-4 whitespace-nowrap"><div class="flex items-center"><div class="w-3 h-3 rounded-full mr-2 ${network === 'eth' ? 'bg-indigo-400' : network === 'bsc' ? 'bg-yellow-400' : 'bg-blue-400'}"></div><span class="font-semibold">${networkConfig[network].name}</span></div></td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-400">${new Date().toLocaleString('pt-BR')}</td>
                <td class="px-6 py-4 whitespace-nowrap font-bold ${typeClass}">${typeIcon} ${type}</td>
                <td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-medium text-white">${tokenValue.toLocaleString('pt-BR', { maximumFractionDigits: 4 })} ${tokenSymbol}</div></td>
                <td class="px-6 py-4 whitespace-nowrap"><div class="text-sm font-bold text-white">${isUnknown ? 'N/A' : '$' + usdValue.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div></td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-400 font-mono" title="${wallet}">${wallet.substring(0, 6)}...${wallet.substring(wallet.length - 4)}</td>
                <td class="px-6 py-4 whitespace-nowrap"><a href="${networkConfig[network].explorer}${txHash}" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:text-blue-300">Ver &#x2197;</a></td>
            `;

            transactionFeed.prepend(row);

            if (transactionFeed.children.length > MAX_FEED_ITEMS) {
                transactionFeed.removeChild(transactionFeed.lastChild);
            }
        }

        function checkAlerts(txData) {
            // Alert for new/meme token buy
            if (txData.isUnknown && txData.type === 'ENTRADA') {
                triggerNewTokenAlert(txData);
                return; // Prioritize new token alert
            }
            // Alert for high value transaction
            const alertValue = parseFloat(alertValueInput.value) || 100000;
            if (txData.usdValue >= alertValue) {
                triggerWhaleAlert(txData);
            }
        }
        
        function triggerWhaleAlert(txData) {
            setupAlertModal('whale', txData);
            const synth = new Tone.Synth({ oscillator: { type: 'fatsawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.5 } }).toDestination();
            synth.triggerAttackRelease("C4", "8n", Tone.now());
        }

        function triggerNewTokenAlert(txData) {
            setupAlertModal('new_token', txData);
            const synth = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, detune: 0, oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.01, sustain: 1, release: 0.5 }, modulation: { type: "square" }, modulationEnvelope: { attack: 0.5, decay: 0, sustain: 1, release: 0.5 } }).toDestination();
            synth.triggerAttackRelease("C5", "4n", Tone.now());
        }

        function setupAlertModal(type, txData) {
            const { network, tokenSymbol, tokenValue, usdValue, wallet } = txData;
            
            const configs = {
                whale: {
                    borderColor: 'border-red-500', bgColor: 'bg-red-900', btnColor: 'bg-red-600', hoverBtnColor: 'hover:bg-red-700',
                    iconPath: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.636 18.364a9 9 0 010-12.728m2.828 9.9a5 5 0 010-7.072" />',
                    iconColor: 'text-red-400',
                    title: 'ALERTA DE BALEIA!',
                    subtitle: 'MovimentaÃ§Ã£o de alto valor detectada!',
                    subtitleColor: 'text-red-200',
                    content: `<p class="text-3xl font-bold text-white my-2">$${usdValue.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p><p class="text-lg text-gray-300">Em <strong class="text-white">${tokenValue.toLocaleString('pt-BR', { maximumFractionDigits: 4 })} ${tokenSymbol}</strong></p>`
                },
                new_token: {
                    borderColor: 'border-amber-400', bgColor: 'bg-amber-900', btnColor: 'bg-amber-600', hoverBtnColor: 'hover:bg-amber-700',
                    iconPath: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l-3 3m6 0l-3 3M5 21v-4m-2 2h4m11-5l-8 8-4-4 1.5-1.5L9 16.5l6.5-6.5L17 11z" />',
                    iconColor: 'text-amber-300',
                    title: 'ðŸ’Ž NOVO TOKEN DETECTADO!',
                    subtitle: 'Baleia adquiriu um token desconhecido!',
                    subtitleColor: 'text-amber-200',
                    content: `<p class="text-3xl font-bold text-white my-2">${tokenValue.toLocaleString('pt-BR', { maximumFractionDigits: 2 })} ${tokenSymbol}</p><p class="text-lg text-gray-300">O valor em USD Ã© desconhecido.</p>`
                }
            };

            const config = configs[type];
            const txType = txData.type;
            const typeClass = txType === 'ENTRADA' ? 'text-green-300' : 'text-red-300';
            
            alertBox.className = `border-4 rounded-2xl shadow-2xl p-8 max-w-lg w-full transform transition-all duration-300 scale-95 ${config.borderColor} ${config.bgColor}`;
            alertCloseBtn.className = `mt-8 w-full text-white font-bold py-3 px-4 rounded-lg transition duration-300 ${config.btnColor} ${config.hoverBtnColor}`;
            alertIcon.innerHTML = config.iconPath;
            alertIcon.className = `h-20 w-20 mx-auto animate-ping ${config.iconColor}`;
            alertTitle.textContent = config.title;
            alertSubtitle.textContent = config.subtitle;
            alertSubtitle.className = `text-xl mt-2 ${config.subtitleColor}`;

            alertContent.innerHTML = `
                ${config.content}
                <p class="text-sm text-gray-400 font-mono mt-4">
                    <strong class="${typeClass}">${txType}</strong> na rede ${networkConfig[network].name}<br>Carteira: ${wallet}
                </p>
            `;
            
            alertModal.classList.remove('hidden');
            alertBox.classList.add('scale-100');
        }


        function closeAlertModal() {
            alertBox.classList.remove('scale-100');
            setTimeout(() => { alertModal.classList.add('hidden'); }, 300);
        }

        // --- FUNÃ‡Ã•ES DE UI ---
        
        function createStatusIndicator(network, status, message) {
            const indicator = document.createElement('div');
            indicator.id = `status-${network}`;
            statusContainer.appendChild(indicator);
            updateStatusIndicator(network, status, message);
        }

        function updateStatusIndicator(network, status, message) {
            const indicator = document.getElementById(`status-${network}`);
            if (!indicator) return;

            const statusClasses = {
                connecting: 'bg-yellow-500 bg-opacity-20 text-yellow-300',
                connected: 'bg-green-500 bg-opacity-20 text-green-300',
                error: 'bg-red-500 bg-opacity-20 text-red-300',
                disconnected: 'bg-gray-600 bg-opacity-20 text-gray-400',
                idle: 'bg-gray-600 bg-opacity-20 text-gray-400'
            };

            const statusIcons = {
                connecting: '<div class="w-3 h-3 bg-yellow-400 rounded-full animate-pulse-fast"></div>',
                connected: '<div class="w-3 h-3 bg-green-400 rounded-full"></div>',
                error: '<div class="w-3 h-3 bg-red-400 rounded-full"></div>',
                disconnected: '<div class="w-3 h-3 bg-gray-500 rounded-full"></div>',
                idle: '<div class="w-3 h-3 bg-gray-500 rounded-full"></div>'
            }
            
            indicator.className = `p-4 rounded-lg flex items-center transition-all duration-300 ${statusClasses[status] || statusClasses.idle}`;
            indicator.innerHTML = `
                ${statusIcons[status] || statusIcons.idle}
                <div class="ml-3">
                    <p class="font-bold">${networkConfig[network].name}</p>
                    <p class="text-sm">${message}</p>
                </div>
            `;
        }

    </script>
</body>
</html>
